N = N/2
}
else
{
N = 3 ∗ N + 1
}
i = i + 1
}
i
rm(list = ls(all = TRUE))
N = as.numeric(readline("EntierN?"))
while(N>1)
{
if (N%%2 == 0)
{
N = N/2
}
else
{
N = 3 ∗ N + 1
}
i = i + 1
}
i
rm(list = ls(all = TRUE))
x = sqrt(2)/2;
i = 1;
while (x < 0.999)
{
x = 4 ∗ x ∗ (1 − x);
i = i + 1;
}
rm(list = ls(all = TRUE));
x = sqrt(2)/2;
i = 1;
while (x < 0.999)
{
x = 4 ∗ x ∗ (1 − x);
i = i + 1;
}
rm(list = ls(all = T RUE))
N = as.numeric(readline(”EntierN?”))
i = 1
while (N > 1)
{if (N%%2 == 0)
{N = N/2}
else {N = 3 ∗ N + 1}
i = i + 1}
i
rm(list = ls(all = TRUE))
N = as.numeric(readline("EntierN?"))
while (N > 1)
{if (N%%2 == 0)
{N = N/2}
else {N = 3 ∗ N + 1}
i = i + 1}
i
rm(list = ls(all = TRUE))
N = as.numeric(readline("EntierN?"))
while (N > 1)
{if (N%%2 == 0)
{N = N/2}
else {N = 3 ∗ N + 1}
i = i + 1}
rm(list = ls(all = TRUE))
N = as.numeric(readline("EntierN?"))
while (N > 1)
{if (N%%2 == 0)
{N = N/2}
else {N = 3 ∗ N + 1}
i = i + 1
}
rm(list = ls(all = TRUE))
N = as.numeric(readline("EntierN?"))
while (N > 1)
{if (N%%2 == 0)
{N = N/2}
else {N = 3 ∗ N + 1}
i = i + 1}
i
rm(list = ls(all = TRUE))
N = as.numeric(readline("EntierN?"))
while (N > 1)
{if (N%%2 == 0)
{N = N/2}
else {N = 3 ∗ N + 1}
i = i + 1}
i
x <- readline("Point d'initialisation: ")
x <- readline("Point d'initialisation: ")
x <- as.numeric(x)
for(n in 1:10^5){
x = 4 * x[n]* (1-x[n])
}
#Présenter cette ligne avant le rest
plot(x[-lenght(x)], x[-1])
x <- as.numeric(x)
for(n in 1:10^5){
x = 4 * x[n]* (1-x[n])
}
#Présenter cette ligne avant le rest
plot(x[-length(x)], x[-1])
x <- readline("Point d'initialisation: ")
x <- as.numeric(x)
for(n in 1:10^5){
x = 4 * x[n]* (1-x[n])
}
#Présenter cette ligne avant le rest
plot(x[-length(x)], x[-1])
x <- readline("Point d'initialisation: ")
x <- as.numeric(x)
for(n in 1:10^5){
x = 4 * x[n]* (1-x[n])
}
#Présenter cette ligne avant le reste
plot(x[-length(x)], x[-1])
x <- readline("Point d'initialisation: ")
rm(list = ls(all = TRUE))
x <- readline("Point d'initialisation: ")
x <- as.numeric(x)
for(n in 1:10^5){
x = 4 * x[n]* (1-x[n])
}
#Présenter cette ligne avant le reste
plot(x[-length(x)], x[-1])
rm(list = ls(all = TRUE))
x <- readline("Point d'initialisation: ")
x <- as.numeric(x)
for(n in 1:10^5){
x = 4 * x[n]* (1-x[n])
}
#Présenter cette ligne avant le reste
plot(x[-length(x)], x[-1])
x <- readline("Point d'initialisation: ")
x <- readline("Point d'initialisation: ")
x <- as.numeric(x)
for(n in 1:10^5){
x = 4 * x[n]* (1-x[n])
}
#Présenter cette ligne avant le reste
plot(x[-length(x)], x[-1])
x <- readline("Point d'initialisation: ")
x <- as.numeric(x)
for(n in 1:10^5){
x = 4 * x[n]* (1-x[n])
}
#Présenter cette ligne avant le reste
plot(x[-length(x)], x[-1])
rm(list = ls(all = TRUE))
x <- as.numeric(readline("Point d'initialisation: "))
x <- as.numeric(readline("Point d'initialisation: "))
x <- as.numeric(readline("Point d'initialisation: "))
x <- as.numeric(readline("Point d'initialisation: "))
for(n in 1:10^5){
x = 4 * x[n]* (1-x[n])
}
rm(list = ls(all = TRUE))
!reb
!rep
x <- as.numeric(readline("Donné moi un chiffre: "))
res<- rep(x, floor(sqrt(x))-1)
if (!0 %in% (res%%(2:floor(sqrt(x))))){    # %% = c'est le modulo
print("ce nb est premier")
}
else {
print("ce nb est non premier")
}
x <- as.numeric(readline("Donné moi un chiffre: "))
res<- rep(x, floor(sqrt(x))-1)
if (!0 %in% (res%%(2:floor(sqrt(x))))){    # %% = c'est le modulo
print("ce nb est premier")
}
else {
print("ce nb est non premier")
}
#pour verifier qu'un nb est premier il faut voir si les nb inferieur ou égaux a sa sqrt sont des diviseur ou non
rm(list = ls(all = TRUE))
x <- as.numeric(readline("Donné moi un chiffre: "))
if (!0 %in% (res%%(2:floor(sqrt(x))))){    # %% = c'est le modulo
print("ce nb est premier")
}
else
print("ce nb est non premier")
#pour verifier qu'un nb est premier il faut voir si les nb inferieur ou égaux a sa sqrt sont des diviseur ou non
rm(list = ls(all = TRUE))
x <- as.numeric(readline("Donné moi un chiffre: "))
if (!0 %in% (res%%(2:floor(sqrt(x)))))    # %% = c'est le modulo
print("ce nb est premier")
else
print("ce nb est non premier")
x <- as.numeric(readline("Donné moi un chiffre: "))
res<- rep(x, floor(sqrt(x))-1)
if (!0 %in% (res%%(2:floor(sqrt(x)))))    # %% = c'est le modulo
print("ce nb est premier")
else
print("ce nb est non premier")
rm(list = ls(all = TRUE))
for (x in 1:10){
f = 1/sqrt(x)-cos(x)
plot(x,f)
}
rm(list = ls(all = TRUE))
for (x in 1:10){
f = 1/sqrt(x)-cos(x)
plot(x,f,x)
}
rm(list = ls(all = TRUE))
for (x in 1:10){
f = 1/sqrt(x)-cos(x)
plot(x,f)
}
rm(list = ls(all = TRUE))
x = 1:10
f = 1/sqrt(x)-cos(x)
plot(x,f)
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
return (f)
}
x = 1:10
plot(x,Fo(x))
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
return (f)
}
x = seq(0.1,10,0.01)
plot(x,Fo(x))
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
return (f)
}
x = seq(0.1,100,0.01)
plot(x,Fo(x))
x = 10
f = 1/sqrt(x)-cos(x)
f
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
return (f)
}
x = seq(0.1,10,2)
plot(x,Fo(x))
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
return (f)
}
x = seq(1,1000,2)
plot(x,Fo(x))
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
return (f)
}
x = seq(1,1000,0.01)
plot(x,Fo(x))
x = seq(1,10,0.01)
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
return (f)
}
x = seq(1,10,0.01)
plot(x,Fo(x))
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
if (f == 0){
print ("x =", x)
}
return (f)
}
x = seq(1,10,0.01)
plot(x,Fo(x))
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
return (f)
}
for (l in 1:10){
if (Fo(x) == 0){
print ("x =", x)
}
l = l - 0.99
}
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
return (f)
}
for (l in 1:10){
if (Fo(l) == 0){
print ("l =", l)
}
l = l - 0.99
}
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
return (f)
}
for (l in 1:10){
if (Fo(l) == 0){
l
}
l = l - 0.99
}
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
return (f)
}
x = seq(0,10,0.01)
plot(x,Fo(x))
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
return (f)
}
x = seq(from=0,to=10,by=0.01)
plot(x,Fo(x))
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
return (f)
}
pos = 0.01
x = seq(from = 0,to = 10,by = pos)
plot(x,Fo(x))
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
return (f)
}
pos = 0.01
x = seq(from = 0,to = 10,by = pos)
plot(x,Fo(x))
delta <- 10^(-2)
x[ which(abs(Fo(x))< delta )]
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
return (f)
}
pos = 0.01
x = seq(from = 0,to = 10,by = pos)
plot(x,Fo(x), type="l")
delta <- 10^(-2)
x[ which(abs(Fo(x))< delta )]
abline(h=10^(-2), col="blue")
rm(list = ls(all = TRUE))
Fo <- function(x){
f = 1/sqrt(x)-cos(x)
return (f)
}
pos = 0.01
x = seq(from = 0,to = 10,by = pos)
plot(x,Fo(x), type="l")
abline(h=10^(-2), col="blue")
delta <- 10^(-2)
x[ which(abs(Fo(x))< delta )]
rm(list = ls(all = TRUE))
rm(list = ls(all = TRUE))
c(seq(2,20,2))
rm(list = ls(all = TRUE))
V = seq(2,20,2)
W = rep(-1,10)
sum(V*W)
rm(list = ls(all = TRUE))
V = seq(2,20,2)
W = rep(-1,10)
V% * %W
matrix(c(V,W),10,2)
rm(list = ls(all = TRUE))
V = seq(2,20,2)
W = rep(-1,10)
V% * %W
cbind(V,W)
rm(list = ls(all = TRUE))
V = seq(2,20,2)
W = rep(-1,10)
V% * %W
cbind(V,W)
rm(list = ls(all = TRUE))
M = runif(n^2,0,1)
N = matrice(M,n,n)
solve(N)
N
rm(list = ls(all = TRUE))
M = runif(n^2,0,1)
N = matrix(M,n,n)
solve(N)
N
rm(list = ls(all = TRUE))
M = runif(n,0,1)
N = matrix(M,n,n)
solve(N)
N
rm(list = ls(all = TRUE))
M = runif(n,0,1)
N = matrix(M,n,n)
C = solve(N)
C
rm(list = ls(all = TRUE))
M = runif(n^2,0,1)
N = matrix(M,n,n)
solve(N)
rm(list = ls(all = TRUE))
M = runif(n^2,0,1)
N = matrix(M,n,n)
solve(N)
rm(list = ls(all = TRUE))
M <- runif(n^2,0,1)
N <- matrix(M,n,n)
C <- solve(N)
C
rm(list = ls(all = TRUE))
M <- runif(n,0,1)
N <- matrix(M,n,n)
C <- solve(N)
C
tic <- proc.time() #start the clock
rm(list = ls(all = TRUE))
n<-500
for (i in 2:n){
M = runif(i^2)
N <- matrix(data = M, row = i, col = i)
tic <- proc.time() #start the clock
res <- solve(N)
tac <- proc.time()-tic  #stop the colck
temps <- c(temps,anumeric (tac[3]))
}
rm(list = ls(all = TRUE))
#Crée un vecteur x
x <- as.numeric(readline("Point d'initialisation: "))
for(n in 1:10^5){
x = 4 * x[n]* (1-x[n])
}
#Présenter cette ligne avant le reste
plot(x[-length(x)], x[-1])
rm(list = ls(all = TRUE))
temps<-c()
n<-500
#calculer l'inverse de la matrice m
for(i in 2:n){
M=runif(i^2)
N<-matrix(data = M, nrow = i, ncol=i)
tic<-proc.time()
res<-solve(N)        #start the clock
tac<-proc.time()-tic #stop the clock
temps<-c(temps,as.numeric(tac[3]))
}
{
plot (2:n,log(temps))   # montrer sur un petit espace une large gamme de valeur
lines(2:n/150-5.5)
}
rm(list = ls(all = TRUE))
temps<-c()
n<-500
#calculer l'inverse de la matrice m
for(i in 2:n){
M=runif(i^2)
M
rm(list = ls(all = TRUE))
temps<-c()
n<-500
#calculer l'inverse de la matrice m
for(i in 2:n){
M=runif(i^2)
M
}
rm(list = ls(all = TRUE))
n<-500
#calculer l'inverse de la matrice m
for(i in 2:n){
M=runif(i^2)
print(M)
}
rm(list = ls(all = TRUE))
temps<-c()
n<-500
#calculer l'inverse de la matrice m
for(i in 2:n){
M = runif(i^2)
N<-matrix(data = M, nrow = i, ncol=i)
tic<-proc.time()
res<-solve(N)        #start the clock
tac<-proc.time()-tic #stop the clock
temps<-c(temps,as.numeric(tac[3]))
}
{
plot (2:n,log(temps))   # montrer sur un petit espace une large gamme de valeur
lines(2:n/150-5.5)
}
rm(list = ls(all = TRUE))
v1 = c(1,-2)
v2 = c(1 ,2)
x = ceiling(runif(n=2)*100)
rm(list = ls(all = TRUE))
v1 = c(1,-2)
v2 = c(1 ,2)
x = ceiling(runif(n=2)*100)
x
#vect libre:
# 1) linéairement independant
# 2) si la seul combinaison lineaire
rm(list = ls(all = TRUE))
rm(list = ls(all = TRUE))
